import type Model from '../data/Model';
import type Maybe from '../types/Maybe';
import type NetworkClient from './NetworkClient';
export declare class Transformers {
    readonly add: <R extends string, T extends Model<R, any>>(resource: R, transformer: (networkClient: TransformingNetworkClient, input: T) => any) => Transformers;
    readonly get: (resource: string) => (networkClient: TransformingNetworkClient, input: any) => any;
    constructor();
}
/**
 * This class wraps around a `NetworkClient`, and transforms plain objects returned by the Mollie API into more
 * convenient JavaScript objects.
 */
export default class TransformingNetworkClient {
    protected readonly networkClient: NetworkClient;
    protected readonly transform: (input: Model<any, Maybe<string>>) => any;
    constructor(networkClient: NetworkClient, transformers: Transformers);
    post<R extends Model<any, any>, U>(...passingArguments: Parameters<NetworkClient['post']>): Promise<U>;
    get<R extends Model<any, any>, U>(...passingArguments: Parameters<NetworkClient['get']>): Promise<U>;
    list<R extends Model<any, any>, U>(...passingArguments: Parameters<NetworkClient['list']>): Promise<U[]>;
    page<R extends Model<any, any>, U>(...passingArguments: Parameters<NetworkClient['page']>): Promise<U[] & {
        links: import("../data/page/Page").PageLinks;
    }>;
    iterate<R extends Model<any, any>, U>(...passingArguments: Parameters<NetworkClient['iterate']>): import("../plumbing/iteration/HelpfulIterator").default<U>;
    patch<R extends Model<any, any>, U>(...passingArguments: Parameters<NetworkClient['patch']>): Promise<U>;
    delete<R extends Model<any, any>, U>(...passingArguments: Parameters<NetworkClient['delete']>): Promise<U>;
}
